/* tslint:disable */
/* eslint-disable */
/**
* Verify that the signature is presented to satisfy SigmaProp conditions.
* @param {Address} address
* @param {Uint8Array} message
* @param {Uint8Array} signature
* @returns {boolean}
*/
export function verify_signature(address: Address, message: Uint8Array, signature: Uint8Array): boolean;
/**
* GET on /info endpoint
* @param {NodeConf} node
* @returns {Promise<any>}
*/
export function get_info(node: NodeConf): Promise<any>;
/**
* GET on /blocks/{header_id}/header endpoint
* @param {NodeConf} node
* @param {BlockId} header_id
* @returns {Promise<any>}
*/
export function get_header(node: NodeConf, header_id: BlockId): Promise<any>;
/**
* GET on /nipopow/proof/{minChainLength}/{suffixLength}/{headerId} endpoint
* @param {NodeConf} node
* @param {number} min_chain_length
* @param {number} suffix_len
* @param {BlockId} header_id
* @returns {Promise<any>}
*/
export function get_nipopow_proof_by_header_id(node: NodeConf, min_chain_length: number, suffix_len: number, header_id: BlockId): Promise<any>;
/**
* GET on /blocks/{header_id}/proofFor/{tx_id} to request the merkle proof for a given transaction
* that belongs to the given header ID.
* @param {NodeConf} node
* @param {BlockId} header_id
* @param {TxId} tx_id
* @returns {Promise<any>}
*/
export function get_blocks_header_id_proof_for_tx_id(node: NodeConf, header_id: BlockId, tx_id: TxId): Promise<any>;
/**
* Given a list of seed nodes, search for peer nodes with an active REST API on port 9053.
*  - `seeds` represents a list of ergo node URLs from which to start peer discovery.
*  - `max_parallel_tasks` represents the maximum number of tasks to spawn for ergo node HTTP
*    requests. Note that the actual number of parallel HTTP requests may well be higher than this
*    number.
*  - `timeout` represents the amount of time that is spent search for peers. Once the timeout
*    value is reached, return with the vec of active peers that have been discovered up to that
*    point in time.
*  - `is_chrome` **MUST** be set to true if running this function on a Chromium-based browser.
*    There are some limitations on this platform regarding network requests. Please see the
*    documentation for [`peer_discovery_chrome`].
* @param {(URL)[]} seeds
* @param {number} max_parallel_requests
* @param {number} timeout_sec
* @param {boolean} is_chrome
* @returns {Promise<PeerUrls>}
*/
export function peer_discovery(seeds: (URL)[], max_parallel_requests: number, timeout_sec: number, is_chrome: boolean): Promise<PeerUrls>;
/**
* An incremental (reusable) version of [`peer_discovery_chrome`] which allows for peer discovery
* to be split into separate sub-tasks.
*
* NOTE: intended to be used only on Chromium based browsers. It works on Firefox and Safari, but
* using `peer_discovery` above gives better performance.
* @param {ChromePeerDiscoveryScan} scan
* @param {number} max_parallel_requests
* @param {number} timeout_sec
* @returns {Promise<any>}
*/
export function incremental_peer_discovery_chrome(scan: ChromePeerDiscoveryScan, max_parallel_requests: number, timeout_sec: number): Promise<any>;
/**
* Decodes a base16 string into an array of bytes
* @param {string} data
* @returns {Uint8Array}
*/
export function base16_decode(data: string): Uint8Array;
/**
* Extracting hints form singed(invalid) Transaction
* @param {Transaction} signed_transaction
* @param {ErgoStateContext} state_context
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @param {Propositions} real_propositions
* @param {Propositions} simulated_propositions
* @returns {TransactionHintsBag}
*/
export function extract_hints(signed_transaction: Transaction, state_context: ErgoStateContext, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes, real_propositions: Propositions, simulated_propositions: Propositions): TransactionHintsBag;
/**
* Verify transaction input's proof
* @param {number} input_idx
* @param {ErgoStateContext} state_context
* @param {Transaction} tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @returns {boolean}
*/
export function verify_tx_input_proof(input_idx: number, state_context: ErgoStateContext, tx: Transaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes): boolean;
/**
* Verify transaction
* @param {Transaction} tx
* @param {ErgoStateContext} state_context
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
*/
export function validate_tx(tx: Transaction, state_context: ErgoStateContext, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes): void;
/**
* Encode a JS array as an Ergo tuple.
* @param {any[]} items
* @returns {any}
*/
export function array_as_tuple(items: any[]): any;
/**
* newtype for box registers R4 - R9
*/
export enum NonMandatoryRegisterId {
/**
* id for R4 register
*/
  R4 = 4,
/**
* id for R5 register
*/
  R5 = 5,
/**
* id for R6 register
*/
  R6 = 6,
/**
* id for R7 register
*/
  R7 = 7,
/**
* id for R8 register
*/
  R8 = 8,
/**
* id for R9 register
*/
  R9 = 9,
}
/**
* Address types
*/
export enum AddressTypePrefix {
/**
* 0x01 - Pay-to-PublicKey(P2PK) address
*/
  P2Pk = 1,
/**
* 0x02 - Pay-to-Script-Hash(P2SH)
*/
  Pay2Sh = 2,
/**
* 0x03 - Pay-to-Script(P2S)
*/
  Pay2S = 3,
}
/**
* Network type
*/
export enum NetworkPrefix {
/**
* Mainnet
*/
  Mainnet = 0,
/**
* Testnet
*/
  Testnet = 16,
}
/**
*
* * An address is a short string corresponding to some script used to protect a box. Unlike (string-encoded) binary
* * representation of a script, an address has some useful characteristics:
* *
* * - Integrity of an address could be checked., as it is incorporating a checksum.
* * - A prefix of address is showing network and an address type.
* * - An address is using an encoding (namely, Base58) which is avoiding similarly l0Oking characters, friendly to
* * double-clicking and line-breaking in emails.
* *
* *
* *
* * An address is encoding network type, address type, checksum, and enough information to watch for a particular scripts.
* *
* * Possible network types are:
* * Mainnet - 0x00
* * Testnet - 0x10
* *
* * For an address type, we form content bytes as follows:
* *
* * P2PK - serialized (compressed) public key
* * P2SH - first 192 bits of the Blake2b256 hash of serialized script bytes
* * P2S  - serialized script
* *
* * Address examples for testnet:
* *
* * 3   - P2PK (3WvsT2Gm4EpsM9Pg18PdY6XyhNNMqXDsvJTbbf6ihLvAmSb7u5RN)
* * ?   - P2SH (rbcrmKEYduUvADj9Ts3dSVSG27h54pgrq5fPuwB)
* * ?   - P2S (Ms7smJwLGbUAjuWQ)
* *
* * for mainnet:
* *
* * 9  - P2PK (9fRAWhdxEsTcdb8PhGNrZfwqa65zfkuYHAMmkQLcic1gdLSV5vA)
* * ?  - P2SH (8UApt8czfFVuTgQmMwtsRBZ4nfWquNiSwCWUjMg)
* * ?  - P2S (4MQyML64GnzMxZgm, BxKBaHkvrTvLZrDcZjcsxsF7aSsrN73ijeFZXtbj4CXZHHcvBtqSxQ)
* *
* *
* * Prefix byte = network type + address type
* *
* * checksum = blake2b256(prefix byte ++ content bytes)
* *
* * address = prefix byte ++ content bytes ++ checksum
* *
* 
*/
export class Address {
  free(): void;
/**
* Re-create the address from ErgoTree that was built from the address
*
* At some point in the past a user entered an address from which the ErgoTree was built.
* Re-create the address from this ErgoTree.
* `tree` - ErgoTree that was created from an Address
* @param {ErgoTree} ergo_tree
* @returns {Address}
*/
  static recreate_from_ergo_tree(ergo_tree: ErgoTree): Address;
/**
* Create a P2PK address from serialized PK bytes(EcPoint/GroupElement)
* @param {Uint8Array} bytes
* @returns {Address}
*/
  static p2pk_from_pk_bytes(bytes: Uint8Array): Address;
/**
* Decode (base58) testnet address from string, checking that address is from the testnet
* @param {string} s
* @returns {Address}
*/
  static from_testnet_str(s: string): Address;
/**
* Decode (base58) mainnet address from string, checking that address is from the mainnet
* @param {string} s
* @returns {Address}
*/
  static from_mainnet_str(s: string): Address;
/**
* Decode (base58) address from string without checking the network prefix
* @param {string} s
* @returns {Address}
*/
  static from_base58(s: string): Address;
/**
* Encode (base58) address
* @param {NetworkPrefix} network_prefix
* @returns {string}
*/
  to_base58(network_prefix: NetworkPrefix): string;
/**
* Decode from a serialized address (that includes the network prefix)
* @param {Uint8Array} data
* @returns {Address}
*/
  static from_bytes(data: Uint8Array): Address;
/**
* Encode address as serialized bytes (that includes the network prefix)
* @param {NetworkPrefix} network_prefix
* @returns {Uint8Array}
*/
  to_bytes(network_prefix: NetworkPrefix): Uint8Array;
/**
* Returns underlying value for each address type
* (serialized EcPoint for P2PK, stored bytes for P2SH and P2S)
* @returns {Uint8Array}
*/
  content_bytes(): Uint8Array;
/**
* Get the type of the address
* @returns {AddressTypePrefix}
*/
  address_type_prefix(): AddressTypePrefix;
/**
* Create an address from a public key
* @param {Uint8Array} bytes
* @returns {Address}
*/
  static from_public_key(bytes: Uint8Array): Address;
/**
* Creates an ErgoTree script from the address
* @returns {ErgoTree}
*/
  to_ergo_tree(): ErgoTree;
}
/**
* BatchMerkleProof type to validate root hash for multiple nodes
*/
export class BatchMerkleProof {
  free(): void;
/**
* Creates a new [`BatchMerkleProof`] from json representation
* @param {any} json
* @returns {BatchMerkleProof}
*/
  static from_json(json: any): BatchMerkleProof;
/**
* Converts [`BatchMerkleProof`] to json representation
* @returns {any}
*/
  to_json(): any;
/**
* Calculates root hash for [`BatchMerkleProof`] and compares it against expected root hash
* @param {Uint8Array} expected_root
* @returns {boolean}
*/
  valid(expected_root: Uint8Array): boolean;
}
/**
* Block header
*/
export class BlockHeader {
  free(): void;
/**
* Parse from JSON (Node API)
* @param {string} json
* @returns {BlockHeader}
*/
  static from_json(json: string): BlockHeader;
/**
* Get Header's id
* @returns {BlockId}
*/
  id(): BlockId;
/**
* Get transactions root
* @returns {Uint8Array}
*/
  transactions_root(): Uint8Array;
}
/**
* Collection of BlockHeaders
*/
export class BlockHeaders {
  free(): void;
/**
* parse BlockHeader array from JSON (Node API)
* @param {any[]} json_vals
* @returns {BlockHeaders}
*/
  static from_json(json_vals: any[]): BlockHeaders;
/**
* Create new collection with one element
* @param {BlockHeader} b
*/
  constructor(b: BlockHeader);
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Add an element to the collection
* @param {BlockHeader} b
*/
  add(b: BlockHeader): void;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {BlockHeader}
*/
  get(index: number): BlockHeader;
}
/**
* Block id
*/
export class BlockId {
  free(): void;
/**
* Parse from base 16 encoded string
* @param {string} id
* @returns {BlockId}
*/
  static from_str(id: string): BlockId;
/**
* Equality check
* @param {BlockId} id
* @returns {boolean}
*/
  equals(id: BlockId): boolean;
}
/**
* Box id (32-byte digest)
*/
export class BoxId {
  free(): void;
/**
* Parse box id (32 byte digest) from base16-encoded string
* @param {string} box_id_str
* @returns {BoxId}
*/
  static from_str(box_id_str: string): BoxId;
/**
* Base16 encoded string
* @returns {string}
*/
  to_str(): string;
/**
* Returns byte array (32 bytes)
* @returns {Uint8Array}
*/
  as_bytes(): Uint8Array;
}
/**
* Selected boxes with change boxes (by [`BoxSelector`])
*/
export class BoxSelection {
  free(): void;
/**
* Create a selection to easily inject custom selection algorithms
* @param {ErgoBoxes} boxes
* @param {ErgoBoxAssetsDataList} change
*/
  constructor(boxes: ErgoBoxes, change: ErgoBoxAssetsDataList);
/**
* Selected boxes to spend as transaction inputs
* @returns {ErgoBoxes}
*/
  boxes(): ErgoBoxes;
/**
* Selected boxes to use as change
* @returns {ErgoBoxAssetsDataList}
*/
  change(): ErgoBoxAssetsDataList;
}
/**
* Box value in nanoERGs with bound checks
*/
export class BoxValue {
  free(): void;
/**
* Recommended (safe) minimal box value to use in case box size estimation is unavailable.
* Allows box size upto 2777 bytes with current min box value per byte of 360 nanoERGs
* @returns {BoxValue}
*/
  static SAFE_USER_MIN(): BoxValue;
/**
* Number of units inside one ERGO (i.e. one ERG using nano ERG representation)
* @returns {I64}
*/
  static UNITS_PER_ERGO(): I64;
/**
* Create from i64 with bounds check
* @param {I64} v
* @returns {BoxValue}
*/
  static from_i64(v: I64): BoxValue;
/**
* Get value as signed 64-bit long (I64)
* @returns {I64}
*/
  as_i64(): I64;
/**
* big-endian byte array representation
* @returns {Uint8Array}
*/
  to_bytes(): Uint8Array;
}
/**
* Node info
*/
export class ChromePeerDiscoveryScan {
  free(): void;
/**
* Create new scan. Note: `seeds` must not be empty.
* @param {(URL)[]} seeds
*/
  constructor(seeds: (URL)[]);
/**
* Returns list of non-seed peers with an active REST API.
* @returns {PeerUrls}
*/
  active_peers(): PeerUrls;
}
/**
* CommitmentHint
*/
export class CommitmentHint {
  free(): void;
}
/**
* Ergo constant(evaluated) values
*/
export class Constant {
  free(): void;
/**
* Returns the debug representation of the type of the constant
* @returns {string}
*/
  dbg_tpe(): string;
/**
* Returns the debug representation of the value of the constant
* @returns {string}
*/
  dbg_inner(): string;
/**
* Decode from Base16-encoded ErgoTree serialized value
* @param {string} base16_bytes_str
* @returns {Constant}
*/
  static decode_from_base16(base16_bytes_str: string): Constant;
/**
* Encode as Base16-encoded ErgoTree serialized value or return an error if serialization
* failed
* @returns {string}
*/
  encode_to_base16(): string;
/**
* Returns serialized bytes or fails with error if Constant cannot be serialized
* @returns {Uint8Array}
*/
  sigma_serialize_bytes(): Uint8Array;
/**
* Create from i32 value
* @param {number} v
* @returns {Constant}
*/
  static from_i32(v: number): Constant;
/**
* Extract i32 value, returning error if wrong type
* @returns {number}
*/
  to_i32(): number;
/**
* Create from i64
* @param {I64} v
* @returns {Constant}
*/
  static from_i64(v: I64): Constant;
/**
* Extract i64 value, returning error if wrong type
* @returns {I64}
*/
  to_i64(): I64;
/**
* Create BigInt constant from byte array (signed bytes bit-endian)
* @param {Uint8Array} num
* @returns {Constant}
*/
  static from_bigint_signed_bytes_be(num: Uint8Array): Constant;
/**
* Create from byte array
* @param {Uint8Array} v
* @returns {Constant}
*/
  static from_byte_array(v: Uint8Array): Constant;
/**
* Extract byte array, returning error if wrong type
* @returns {Uint8Array}
*/
  to_byte_array(): Uint8Array;
/**
* Create `Coll[Int]` from integer array
* @param {Int32Array} arr
* @returns {Constant}
*/
  static from_i32_array(arr: Int32Array): Constant;
/**
* Extract `Coll[Int]` as integer array
* @returns {Int32Array}
*/
  to_i32_array(): Int32Array;
/**
* Create `Coll[Long]` from string array
* @param {any[]} arr
* @returns {Constant}
*/
  static from_i64_str_array(arr: any[]): Constant;
/**
* Extract `Coll[Long]` as string array
* @returns {any[]}
*/
  to_i64_str_array(): any[];
/**
* Extract `Coll[Coll[Byte]]` as array of byte arrays
* @returns {(Uint8Array)[]}
*/
  to_coll_coll_byte(): (Uint8Array)[];
/**
* Create `Coll[Coll[Byte]]` from array byte array
* @param {(Uint8Array)[]} arr
* @returns {Constant}
*/
  static from_coll_coll_byte(arr: (Uint8Array)[]): Constant;
/**
* Parse raw `EcPoint` value from bytes and make `ProveDlog` constant
* @param {Uint8Array} bytes
* @returns {Constant}
*/
  static from_ecpoint_bytes(bytes: Uint8Array): Constant;
/**
* Parse raw `EcPoint` value from bytes and make `GroupElement` constant
* @param {Uint8Array} bytes
* @returns {Constant}
*/
  static from_ecpoint_bytes_group_element(bytes: Uint8Array): Constant;
/**
* Create `(Coll[Byte], Coll[Byte])` tuple Constant
* @param {Uint8Array} bytes1
* @param {Uint8Array} bytes2
* @returns {Constant}
*/
  static from_tuple_coll_bytes(bytes1: Uint8Array, bytes2: Uint8Array): Constant;
/**
* Extract `(Coll[Byte], Coll[Byte])` tuple from Constant as array of Uint8Array
* @returns {(Uint8Array)[]}
*/
  to_tuple_coll_bytes(): (Uint8Array)[];
/**
* Create `(Int, Int)` tuple Constant
* @returns {any[]}
*/
  to_tuple_i32(): any[];
/**
* Create `(Long, Long)` tuple Constant
* @param {I64} l1
* @param {I64} l2
* @returns {Constant}
*/
  static from_tuple_i64(l1: I64, l2: I64): Constant;
/**
* Extract `(Long, Long)` tuple from Constant as array of strings
* @returns {any[]}
*/
  to_tuple_i64(): any[];
/**
* Create from ErgoBox value
* @param {ErgoBox} v
* @returns {Constant}
*/
  static from_ergo_box(v: ErgoBox): Constant;
/**
* Extract ErgoBox value, returning error if wrong type
* @returns {ErgoBox}
*/
  to_ergo_box(): ErgoBox;
/**
* Create Constant with Unit value
* @returns {Constant}
*/
  static unit(): Constant;
/**
* Returns true if constant value is Unit
* @returns {boolean}
*/
  is_unit(): boolean;
/**
* Create a Constant from JS value
* JS types are converted to the following Ergo types:
* Number -> Int,
* String -> Long,
* BigInt -> BigInt,
* use array_as_tuple() to encode Ergo tuples
* @param {any} value
* @returns {Constant}
*/
  static from_js(value: any): Constant;
/**
* Extract JS value from Constant
* Ergo types are converted to the following JS types:
* Byte -> Number,
* Short -> Number,
* Int -> Number,
* Long -> String,
* BigInt -> BigInt,
* Ergo tuples are encoded as arrays
* @returns {any}
*/
  to_js(): any;
}
/**
* User-defined variables to be put into context
*/
export class ContextExtension {
  free(): void;
/**
* Create new ContextExtension instance
*/
  constructor();
/**
* Set the supplied pair in the ContextExtension
* @param {number} id
* @param {Constant} value
*/
  set_pair(id: number, value: Constant): void;
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* get from map or fail if key is missing
* @param {number} key
* @returns {Constant}
*/
  get(key: number): Constant;
/**
* Returns all keys in the map
* @returns {Uint8Array}
*/
  keys(): Uint8Array;
/**
* Returns serialized bytes or fails with error if ContextExtension cannot be serialized
* @returns {Uint8Array}
*/
  sigma_serialize_bytes(): Uint8Array;
}
/**
* Defines the contract(script) that will be guarding box contents
*/
export class Contract {
  free(): void;
/**
* Create new contract from ErgoTree
* @param {ErgoTree} ergo_tree
* @returns {Contract}
*/
  static new(ergo_tree: ErgoTree): Contract;
/**
* create new contract that allow spending of the guarded box by a given recipient ([`Address`])
* @param {Address} recipient
* @returns {Contract}
*/
  static pay_to_address(recipient: Address): Contract;
/**
* Get the ErgoTree of the contract
* @returns {ErgoTree}
*/
  ergo_tree(): ErgoTree;
}
/**
* Inputs, that are used to enrich script context, but won't be spent by the transaction
*/
export class DataInput {
  free(): void;
/**
* Parse box id (32 byte digest) from base16-encoded string
* @param {BoxId} box_id
*/
  constructor(box_id: BoxId);
/**
* Get box id
* @returns {BoxId}
*/
  box_id(): BoxId;
}
/**
* DataInput collection
*/
export class DataInputs {
  free(): void;
/**
* Create empty DataInputs
*/
  constructor();
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {DataInput}
*/
  get(index: number): DataInput;
/**
* Adds an elements to the collection
* @param {DataInput} elem
*/
  add(elem: DataInput): void;
}
/**
* According to
* BIP-44 <https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki>
* and EIP-3 <https://github.com/ergoplatform/eips/blob/master/eip-0003.md>
*/
export class DerivationPath {
  free(): void;
/**
* Create derivation path for a given account index (hardened) and address indices
* `m / 44' / 429' / acc' / 0 / address[0] / address[1] / ...`
* or `m / 44' / 429' / acc' / 0` if address indices are empty
* change is always zero according to EIP-3
* acc is expected as a 31-bit value (32th bit should not be set)
* @param {number} acc
* @param {Uint32Array} address_indices
* @returns {DerivationPath}
*/
  static new(acc: number, address_indices: Uint32Array): DerivationPath;
/**
* Create root derivation path
* @returns {DerivationPath}
*/
  static master_path(): DerivationPath;
/**
* Returns the length of the derivation path
* @returns {number}
*/
  depth(): number;
/**
* Returns a new path with the last element of the deriviation path being increased, e.g. m/1/2 -> m/1/3
* Returns an empty path error if the path is empty (master node)
* @returns {DerivationPath}
*/
  next(): DerivationPath;
/**
* String representation of derivation path
* E.g m/44'/429'/0'/0/1
* @returns {string}
*/
  toString(): string;
/**
* Create a derivation path from a formatted string
* E.g "m/44'/429'/0'/0/1"
* @param {string} path
* @returns {DerivationPath}
*/
  static from_string(path: string): DerivationPath;
/**
* For 0x21 Sign Transaction command of Ergo Ledger App Protocol
* P2PK Sign (0x0D) instruction
* Sign calculated TX hash with private key for provided BIP44 path.
* Data:
*
* Field
* Size (B)
* Description
*
* BIP32 path length
* 1
* Value: 0x02-0x0A (2-10). Number of path components
*
* First derivation index
* 4
* Big-endian. Value: 44’
*
* Second derivation index
* 4
* Big-endian. Value: 429’ (Ergo coin id)
*
* Optional Third index
* 4
* Big-endian. Any valid bip44 hardened value.
* ...
* Optional Last index
* 4
* Big-endian. Any valid bip44 value.
* @returns {Uint8Array}
*/
  ledger_bytes(): Uint8Array;
}
/**
* Ergo box, that is taking part in some transaction on the chain
* Differs with [`ErgoBoxCandidate`] by added transaction id and an index in the input of that transaction
*/
export class ErgoBox {
  free(): void;
/**
* make a new box with:
* `value` - amount of money associated with the box
* `contract` - guarding contract([`Contract`]), which should be evaluated to true in order
* to open(spend) this box
* `creation_height` - height when a transaction containing the box is created.
* `tx_id` - transaction id in which this box was "created" (participated in outputs)
* `index` - index (in outputs) in the transaction
* @param {BoxValue} value
* @param {number} creation_height
* @param {Contract} contract
* @param {TxId} tx_id
* @param {number} index
* @param {Tokens} tokens
*/
  constructor(value: BoxValue, creation_height: number, contract: Contract, tx_id: TxId, index: number, tokens: Tokens);
/**
* Get box id
* @returns {BoxId}
*/
  box_id(): BoxId;
/**
* Get id of transaction which created the box
* @returns {TxId}
*/
  tx_id(): TxId;
/**
* Index of this box in transaction outputs
* @returns {number}
*/
  index(): number;
/**
* Get box creation height
* @returns {number}
*/
  creation_height(): number;
/**
* Get tokens for box
* @returns {Tokens}
*/
  tokens(): Tokens;
/**
* Get ergo tree for box
* @returns {ErgoTree}
*/
  ergo_tree(): ErgoTree;
/**
* Get box value in nanoERGs
* @returns {BoxValue}
*/
  value(): BoxValue;
/**
* Returns value (ErgoTree constant) stored in the register or None if the register is empty or cannot be parsed
* @param {NonMandatoryRegisterId} register_id
* @returns {Constant | undefined}
*/
  register_value(register_id: NonMandatoryRegisterId): Constant | undefined;
/**
* JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
* @returns {string}
*/
  to_json(): string;
/**
* JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
* (similar to [`Self::to_json`], but as JS object with box value and token amounts encoding as strings)
* @returns {any}
*/
  to_js_eip12(): any;
/**
* parse from JSON
* supports Ergo Node/Explorer API and box values and token amount encoded as strings
* @param {string} json
* @returns {ErgoBox}
*/
  static from_json(json: string): ErgoBox;
/**
* Serialized additional register as defined in ErgoBox serialization (registers count,
* followed by every non-empyt register value serialized)
* @returns {Uint8Array}
*/
  serialized_additional_registers(): Uint8Array;
/**
* Returns serialized bytes or fails with error if cannot be serialized
* @returns {Uint8Array}
*/
  sigma_serialize_bytes(): Uint8Array;
/**
* Parses ErgoBox or fails with error
* @param {Uint8Array} data
* @returns {ErgoBox}
*/
  static sigma_parse_bytes(data: Uint8Array): ErgoBox;
/**
* Create ErgoBox from ErgoBoxCandidate by adding transaction id
* and index of the box in the transaction
* @param {ErgoBoxCandidate} candidate
* @param {TxId} tx_id
* @param {number} index
* @returns {ErgoBox}
*/
  static from_box_candidate(candidate: ErgoBoxCandidate, tx_id: TxId, index: number): ErgoBox;
}
/**
* Pair of <value, tokens> for an box
*/
export class ErgoBoxAssetsData {
  free(): void;
/**
* Create new instance
* @param {BoxValue} value
* @param {Tokens} tokens
*/
  constructor(value: BoxValue, tokens: Tokens);
/**
* Value part of the box
* @returns {BoxValue}
*/
  value(): BoxValue;
/**
* Tokens part of the box
* @returns {Tokens}
*/
  tokens(): Tokens;
}
/**
* List of asset data for a box
*/
export class ErgoBoxAssetsDataList {
  free(): void;
/**
* Create empty Tokens
*/
  constructor();
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {ErgoBoxAssetsData}
*/
  get(index: number): ErgoBoxAssetsData;
/**
* Adds an elements to the collection
* @param {ErgoBoxAssetsData} elem
*/
  add(elem: ErgoBoxAssetsData): void;
}
/**
* ErgoBox candidate not yet included in any transaction on the chain
*/
export class ErgoBoxCandidate {
  free(): void;
/**
* Create a box with miner's contract and given value
* @param {BoxValue} fee_amount
* @param {number} creation_height
* @returns {ErgoBoxCandidate}
*/
  static new_miner_fee_box(fee_amount: BoxValue, creation_height: number): ErgoBoxCandidate;
/**
* Returns value (ErgoTree constant) stored in the register or None if the register is empty or cannot be parsed
* @param {NonMandatoryRegisterId} register_id
* @returns {Constant | undefined}
*/
  register_value(register_id: NonMandatoryRegisterId): Constant | undefined;
/**
* Get box creation height
* @returns {number}
*/
  creation_height(): number;
/**
* Get tokens for box
* @returns {Tokens}
*/
  tokens(): Tokens;
/**
* Get ergo tree for box
* @returns {ErgoTree}
*/
  ergo_tree(): ErgoTree;
/**
* Get box value in nanoERGs
* @returns {BoxValue}
*/
  value(): BoxValue;
/**
* Serialized additional register as defined in ErgoBox serialization (registers count,
* followed by every non-empyt register value serialized)
* @returns {Uint8Array}
*/
  serialized_additional_registers(): Uint8Array;
}
/**
* ErgoBoxCandidate builder
*/
export class ErgoBoxCandidateBuilder {
  free(): void;
/**
* Create builder with required box parameters:
* `value` - amount of money associated with the box
* `contract` - guarding contract([`Contract`]), which should be evaluated to true in order
* to open(spend) this box
* `creation_height` - height when a transaction containing the box is created.
* It should not exceed height of the block, containing the transaction with this box.
* @param {BoxValue} value
* @param {Contract} contract
* @param {number} creation_height
*/
  constructor(value: BoxValue, contract: Contract, creation_height: number);
/**
* Set minimal value (per byte of the serialized box size)
* @param {number} new_min_value_per_byte
*/
  set_min_box_value_per_byte(new_min_value_per_byte: number): void;
/**
* Get minimal value (per byte of the serialized box size)
* @returns {number}
*/
  min_box_value_per_byte(): number;
/**
* Set new box value
* @param {BoxValue} new_value
*/
  set_value(new_value: BoxValue): void;
/**
* Get box value
* @returns {BoxValue}
*/
  value(): BoxValue;
/**
* Calculate serialized box size(in bytes)
* @returns {number}
*/
  calc_box_size_bytes(): number;
/**
* Calculate minimal box value for the current box serialized size(in bytes)
* @returns {BoxValue}
*/
  calc_min_box_value(): BoxValue;
/**
* Set register with a given id (R4-R9) to the given value
* @param {NonMandatoryRegisterId} register_id
* @param {Constant} value
*/
  set_register_value(register_id: NonMandatoryRegisterId, value: Constant): void;
/**
* Returns register value for the given register id (R4-R9), or None if the register is empty
* @param {NonMandatoryRegisterId} register_id
* @returns {Constant | undefined}
*/
  register_value(register_id: NonMandatoryRegisterId): Constant | undefined;
/**
* Delete register value(make register empty) for the given register id (R4-R9)
* @param {NonMandatoryRegisterId} register_id
*/
  delete_register_value(register_id: NonMandatoryRegisterId): void;
/**
* Mint token, as defined in <https://github.com/ergoplatform/eips/blob/master/eip-0004.md>
* `token` - token id(box id of the first input box in transaction) and token amount,
* `token_name` - token name (will be encoded in R4),
* `token_desc` - token description (will be encoded in R5),
* `num_decimals` - number of decimals (will be encoded in R6)
* @param {Token} token
* @param {string} token_name
* @param {string} token_desc
* @param {number} num_decimals
*/
  mint_token(token: Token, token_name: string, token_desc: string, num_decimals: number): void;
/**
* Add given token id and token amount
* @param {TokenId} token_id
* @param {TokenAmount} amount
*/
  add_token(token_id: TokenId, amount: TokenAmount): void;
/**
* Build the box candidate
* @returns {ErgoBoxCandidate}
*/
  build(): ErgoBoxCandidate;
}
/**
* Collection of ErgoBoxCandidates
*/
export class ErgoBoxCandidates {
  free(): void;
/**
* Create new outputs
* @param {ErgoBoxCandidate} box_candidate
*/
  constructor(box_candidate: ErgoBoxCandidate);
/**
* sometimes it's useful to keep track of an empty list
* but keep in mind Ergo transactions need at least 1 output
* @returns {ErgoBoxCandidates}
*/
  static empty(): ErgoBoxCandidates;
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {ErgoBoxCandidate}
*/
  get(index: number): ErgoBoxCandidate;
/**
* Add an element to the collection
* @param {ErgoBoxCandidate} b
*/
  add(b: ErgoBoxCandidate): void;
}
/**
* Collection of ErgoBox'es
*/
export class ErgoBoxes {
  free(): void;
/**
* parse ErgoBox array from json
* @param {any[]} json_vals
* @returns {ErgoBoxes}
*/
  static from_boxes_json(json_vals: any[]): ErgoBoxes;
/**
* Create new collection with one element
* @param {ErgoBox} b
*/
  constructor(b: ErgoBox);
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Add an element to the collection
* @param {ErgoBox} b
*/
  add(b: ErgoBox): void;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {ErgoBox}
*/
  get(index: number): ErgoBox;
/**
* Empty ErgoBoxes
* @returns {ErgoBoxes}
*/
  static empty(): ErgoBoxes;
}
/**
* Blockchain state (last headers, etc.)
*/
export class ErgoStateContext {
  free(): void;
/**
* Create new context from pre-header
* @param {PreHeader} pre_header
* @param {BlockHeaders} headers
* @param {Parameters} parameters
*/
  constructor(pre_header: PreHeader, headers: BlockHeaders, parameters: Parameters);
}
/**
* The root of ErgoScript IR. Serialized instances of this class are self sufficient and can be passed around.
*/
export class ErgoTree {
  free(): void;
/**
* Decode from base16 encoded serialized ErgoTree
* @param {string} s
* @returns {ErgoTree}
*/
  static from_base16_bytes(s: string): ErgoTree;
/**
* Decode from encoded serialized ErgoTree
* @param {Uint8Array} data
* @returns {ErgoTree}
*/
  static from_bytes(data: Uint8Array): ErgoTree;
/**
* Returns serialized bytes or fails with error if ErgoTree cannot be serialized
* @returns {Uint8Array}
*/
  sigma_serialize_bytes(): Uint8Array;
/**
* Returns Base16-encoded serialized bytes
* @returns {string}
*/
  to_base16_bytes(): string;
/**
* Returns constants number as stored in serialized ErgoTree or error if the parsing of
* constants is failed
* @returns {number}
*/
  constants_len(): number;
/**
* Returns constant with given index (as stored in serialized ErgoTree)
* or None if index is out of bounds
* or error if constants parsing were failed
* @param {number} index
* @returns {Constant | undefined}
*/
  get_constant(index: number): Constant | undefined;
/**
* Consumes the calling ErgoTree and returns new ErgoTree with a new constant value
* for a given index in constants list (as stored in serialized ErgoTree), or an error.
* After the call the calling ErgoTree will be null.
* @param {number} index
* @param {Constant} constant
* @returns {ErgoTree}
*/
  with_constant(index: number, constant: Constant): ErgoTree;
/**
* Serialized proposition expression of SigmaProp type with
* ConstantPlaceholder nodes instead of Constant nodes
* @returns {Uint8Array}
*/
  template_bytes(): Uint8Array;
/**
* Returns pretty printed tree
* @returns {string}
*/
  pretty_print(): string;
}
/**
* Extented public key implemented according to BIP-32
*/
export class ExtPubKey {
  free(): void;
/**
* Create ExtPubKey from public key bytes (from SEC1 compressed), chain code and derivation
* path
* @param {Uint8Array} public_key_bytes
* @param {Uint8Array} chain_code
* @param {DerivationPath} derivation_path
* @returns {ExtPubKey}
*/
  static new(public_key_bytes: Uint8Array, chain_code: Uint8Array, derivation_path: DerivationPath): ExtPubKey;
/**
* Soft derivation of the child public key with a given index
* index is expected to be a 31-bit value(32th bit should not be set)
* @param {number} index
* @returns {ExtPubKey}
*/
  child(index: number): ExtPubKey;
/**
* Derive a new extended pub key from the derivation path
* @param {DerivationPath} path
* @returns {ExtPubKey}
*/
  derive(path: DerivationPath): ExtPubKey;
/**
* Create address (P2PK) from this extended public key
* @returns {Address}
*/
  to_address(): Address;
/**
* Chain code of the `ExtPubKey`
* @returns {Uint8Array}
*/
  chain_code(): Uint8Array;
/**
* Public key bytes of the `ExtPubKey`
* @returns {Uint8Array}
*/
  pub_key_bytes(): Uint8Array;
}
/**
* Extented secret key implemented according to BIP-32
*/
export class ExtSecretKey {
  free(): void;
/**
* Create ExtSecretKey from secret key bytes, chain code and derivation path
* @param {Uint8Array} secret_key_bytes
* @param {Uint8Array} chain_code
* @param {DerivationPath} derivation_path
* @returns {ExtSecretKey}
*/
  static new(secret_key_bytes: Uint8Array, chain_code: Uint8Array, derivation_path: DerivationPath): ExtSecretKey;
/**
* Derive root extended secret key
* @param {Uint8Array} seed_bytes
* @returns {ExtSecretKey}
*/
  static derive_master(seed_bytes: Uint8Array): ExtSecretKey;
/**
* Derive a new extended secret key from the provided index
* The index is in the form of soft or hardened indices
* For example: 4 or 4' respectively
* @param {string} index
* @returns {ExtSecretKey}
*/
  child(index: string): ExtSecretKey;
/**
* Derive a new extended secret key from the derivation path
* @param {DerivationPath} path
* @returns {ExtSecretKey}
*/
  derive(path: DerivationPath): ExtSecretKey;
/**
* The bytes of the associated secret key
* @returns {Uint8Array}
*/
  secret_key_bytes(): Uint8Array;
/**
* The extended public key associated with this secret key
* @returns {ExtPubKey}
*/
  public_key(): ExtPubKey;
/**
* Derivation path associated with the ext secret key
* @returns {DerivationPath}
*/
  path(): DerivationPath;
}
/**
* HintsBag
*/
export class HintsBag {
  free(): void;
/**
* Empty HintsBag
* @returns {HintsBag}
*/
  static empty(): HintsBag;
/**
* Add commitment hint to the bag
* @param {CommitmentHint} hint
*/
  add_commitment(hint: CommitmentHint): void;
/**
* Length of HintsBag
* @returns {number}
*/
  len(): number;
/**
* Get commitment
* @param {number} index
* @returns {CommitmentHint}
*/
  get(index: number): CommitmentHint;
}
/**
* Wrapper for i64 for JS/TS because JS Number can only represent 53 bits
* see <https://stackoverflow.com/questions/17320706/javascript-long-integer>
*/
export class I64 {
  free(): void;
/**
* Create from a standard rust string representation
* @param {string} string
* @returns {I64}
*/
  static from_str(string: string): I64;
/**
* String representation of the value for use from environments that don't support i64
* @returns {string}
*/
  to_str(): string;
/**
* Get the value as JS number (64-bit float)
* @returns {number}
*/
  as_num(): number;
/**
* Addition with overflow check
* @param {I64} other
* @returns {I64}
*/
  checked_add(other: I64): I64;
}
/**
* Signed inputs used in signed transactions
*/
export class Input {
  free(): void;
/**
* Get box id
* @returns {BoxId}
*/
  box_id(): BoxId;
/**
* Get the spending proof
* @returns {ProverResult}
*/
  spending_proof(): ProverResult;
}
/**
* Collection of signed inputs
*/
export class Inputs {
  free(): void;
/**
* Create empty Inputs
*/
  constructor();
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {Input}
*/
  get(index: number): Input;
}
/**
* A level node in a merkle proof
*/
export class LevelNode {
  free(): void;
/**
* Creates a new LevelNode from a 32 byte hash and side that the node belongs on in the tree. Fails if the digest is not 32 bytes
* @param {Uint8Array} hash
* @param {number} side
* @returns {LevelNode}
*/
  static new(hash: Uint8Array, side: number): LevelNode;
/**
* Returns the associated digest (hash) with this node. Returns an empty array if there's no hash
*/
  readonly digest: Uint8Array;
/**
* Returns the associated side with this node (0 = Left, 1 = Right)
*/
  readonly side: number;
}
/**
* A MerkleProof type. Given leaf data and levels (bottom-upwards), the root hash can be computed and validated
*/
export class MerkleProof {
  free(): void;
/**
* Creates a new merkle proof with given leaf data and level data (bottom-upwards)
* You can verify it against a Blakeb256 root hash by using [`Self::valid()`]
* Add a node by using [`Self::add_node()`]
* Each digest on the level must be exactly 32 bytes
* @param {Uint8Array} leaf_data
* @returns {MerkleProof}
*/
  static new(leaf_data: Uint8Array): MerkleProof;
/**
* Adds a new node to the MerkleProof above the current nodes
* @param {LevelNode} level
*/
  add_node(level: LevelNode): void;
/**
* Validates the Merkle proof against the root hash
* @param {Uint8Array} expected_root
* @returns {boolean}
*/
  valid(expected_root: Uint8Array): boolean;
}
/**
* helper methods to get the fee address for various networks
*/
export class MinerAddress {
  free(): void;
/**
* Miner fee Base58 encoded P2S address on mainnet
* @returns {string}
*/
  static mainnet_fee_address(): string;
/**
* Miner fee Base58 encoded P2S address on testnet
* @returns {string}
*/
  static testnet_fee_address(): string;
}
/**
* Mnemonic
*/
export class Mnemonic {
  free(): void;
/**
* Convert a mnemonic phrase into a mnemonic seed
* mnemonic_pass is optional and is used to salt the seed
* @param {string} mnemonic_phrase
* @param {string} mnemonic_pass
* @returns {Uint8Array}
*/
  static to_seed(mnemonic_phrase: string, mnemonic_pass: string): Uint8Array;
}
/**
* Combination of an Address with a network
* These two combined together form a base58 encoding
*/
export class NetworkAddress {
  free(): void;
/**
* create a new NetworkAddress(address + network prefix) for a given network type
* @param {NetworkPrefix} network
* @param {Address} address
* @returns {NetworkAddress}
*/
  static new(network: NetworkPrefix, address: Address): NetworkAddress;
/**
* Decode (base58) a NetworkAddress (address + network prefix) from string
* @param {string} s
* @returns {NetworkAddress}
*/
  static from_base58(s: string): NetworkAddress;
/**
* Encode (base58) address
* @returns {string}
*/
  to_base58(): string;
/**
* Decode from a serialized address
* @param {Uint8Array} data
* @returns {NetworkAddress}
*/
  static from_bytes(data: Uint8Array): NetworkAddress;
/**
* Encode address as serialized bytes
* @returns {Uint8Array}
*/
  to_bytes(): Uint8Array;
/**
* Network for the address
* @returns {NetworkPrefix}
*/
  network(): NetworkPrefix;
/**
* Get address without network information
* @returns {Address}
*/
  address(): Address;
}
/**
* A structure representing NiPoPow proof.
*/
export class NipopowProof {
  free(): void;
/**
* Implementation of the ≥ algorithm from [`KMZ17`], see Algorithm 4
*
* [`KMZ17`]: https://fc20.ifca.ai/preproceedings/74.pdf
* @param {NipopowProof} that
* @returns {boolean}
*/
  is_better_than(that: NipopowProof): boolean;
/**
* JSON representation as text
* @returns {string}
*/
  to_json(): string;
/**
* Get suffix head
* @returns {PoPowHeader}
*/
  suffix_head(): PoPowHeader;
/**
* Parse from JSON
* supports Ergo Node/Explorer API and box values and token amount encoded as strings
* @param {string} json
* @returns {NipopowProof}
*/
  static from_json(json: string): NipopowProof;
}
/**
* A verifier for PoPoW proofs. During its lifetime, it processes many proofs with the aim of
* deducing at any given point what is the best (sub)chain rooted at the specified genesis.
*/
export class NipopowVerifier {
  free(): void;
/**
* Create new instance
* @param {BlockId} genesis_block_id
*/
  constructor(genesis_block_id: BlockId);
/**
* Return best proof
* @returns {NipopowProof | undefined}
*/
  best_proof(): NipopowProof | undefined;
/**
* Returns chain of `BlockHeader`s from the best proof.
* @returns {BlockHeaders}
*/
  best_chain(): BlockHeaders;
/**
* Process given proof
* @param {NipopowProof} new_proof
*/
  process(new_proof: NipopowProof): void;
}
/**
* Node configuration
*/
export class NodeConf {
  free(): void;
/**
* Create a node configuration
* @param {URL} url
*/
  constructor(url: URL);
}
/**
* Node info
*/
export class NodeInfo {
  free(): void;
/**
* Get name of the ergo node
* @returns {string}
*/
  name(): string;
/**
* Returns true iff the ergo node is at least v4.0.100. This is important due to the EIP-37
* hard-fork.
* @returns {boolean}
*/
  is_at_least_version_4_0_100(): boolean;
}
/**
* Blockchain parameters
*/
export class Parameters {
  free(): void;
/**
* Return default blockchain parameters that were set at genesis
* @returns {Parameters}
*/
  static default_parameters(): Parameters;
/**
* Get current block version
* @returns {number}
*/
  block_version(): number;
/**
* Cost of storing 1 byte per Storage Period of block chain
* @returns {number}
*/
  storage_fee_factor(): number;
/**
* Minimum value per byte an output must have to not be considered dust
* @returns {number}
*/
  min_value_per_byte(): number;
/**
* Maximum size of transactions size in a block
* @returns {number}
*/
  max_block_size(): number;
/**
* Maximum total computation cost in a block
* @returns {number}
*/
  max_block_cost(): number;
/**
* Cost of accessing a single token
* @returns {number}
*/
  token_access_cost(): number;
/**
* Validation cost per one transaction input
* @returns {number}
*/
  input_cost(): number;
/**
* Validation cost per data input
* @returns {number}
*/
  data_input_cost(): number;
/**
* Validation cost per one output
* @returns {number}
*/
  output_cost(): number;
}
/**
* List of peer urls returned from `peer_discovery`. We need this wrapper struct because the
* `wasm_bindgen` macro currently cannot deal with `Result<Box<[T]>, JsValue>`, for any value `T`
* that can be converted into a `JsValue` (`Result<Box<[web_sys::Url]>, JsValue>` would be a
* convenient return type for `peer_discovery`).
*/
export class PeerUrls {
  free(): void;
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {URL}
*/
  get(index: number): URL;
}
/**
* PoPowHeader structure. Represents the block header and unpacked interlinks
*/
export class PoPowHeader {
  free(): void;
/**
* Returns block header
* @returns {BlockHeader}
*/
  header(): BlockHeader;
/**
* Returns interlinks for PoPowHeader
* @returns {any}
*/
  interlinks(): any;
/**
* Returns interlinks proof [`crate::batchmerkleproof::BatchMerkleProof`]
* @returns {BatchMerkleProof}
*/
  interlinks_proof(): BatchMerkleProof;
/**
* Validates interlinks merkle root with compact merkle multiproof. See [`PoPowHeader::interlinks_proof`] for BatchMerkleProof access
* @returns {boolean}
*/
  check_interlinks_proof(): boolean;
/**
* Returns block height for Header
* @returns {number}
*/
  height(): number;
/**
* Returns Block ID for Header
* @returns {BlockId}
*/
  id(): BlockId;
}
/**
* Block header with the current `spendingTransaction`, that can be predicted
* by a miner before it's formation
*/
export class PreHeader {
  free(): void;
/**
* Create using data from block header
* @param {BlockHeader} block_header
* @returns {PreHeader}
*/
  static from_block_header(block_header: BlockHeader): PreHeader;
}
/**
* Propositions list(public keys)
*/
export class Propositions {
  free(): void;
/**
* Create empty proposition holder
*/
  constructor();
/**
* Adding new proposition
* @param {Uint8Array} proposition
*/
  add_proposition_from_byte(proposition: Uint8Array): void;
}
/**
* Proof of correctness of tx spending
*/
export class ProverResult {
  free(): void;
/**
* Get proof
* @returns {Uint8Array}
*/
  proof(): Uint8Array;
/**
* Get extension
* @returns {ContextExtension}
*/
  extension(): ContextExtension;
/**
* JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
* @returns {string}
*/
  to_json(): string;
}
/**
* Represent `reduced` transaction, i.e. unsigned transaction where each unsigned input
* is augmented with ReducedInput which contains a script reduction result.
* After an unsigned transaction is reduced it can be signed without context.
* Thus, it can be serialized and transferred for example to Cold Wallet and signed
* in an environment where secrets are known.
* see EIP-19 for more details -
* <https://github.com/ergoplatform/eips/blob/f280890a4163f2f2e988a0091c078e36912fc531/eip-0019.md>
*/
export class ReducedTransaction {
  free(): void;
/**
* Returns `reduced` transaction, i.e. unsigned transaction where each unsigned input
* is augmented with ReducedInput which contains a script reduction result.
* @param {UnsignedTransaction} unsigned_tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @param {ErgoStateContext} state_context
* @returns {ReducedTransaction}
*/
  static from_unsigned_tx(unsigned_tx: UnsignedTransaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes, state_context: ErgoStateContext): ReducedTransaction;
/**
* Returns serialized bytes or fails with error if cannot be serialized
* @returns {Uint8Array}
*/
  sigma_serialize_bytes(): Uint8Array;
/**
* Parses ReducedTransaction or fails with error
* @param {Uint8Array} data
* @returns {ReducedTransaction}
*/
  static sigma_parse_bytes(data: Uint8Array): ReducedTransaction;
/**
* Returns the unsigned transaction
* @returns {UnsignedTransaction}
*/
  unsigned_tx(): UnsignedTransaction;
}
/**
* Secret key for the prover
*/
export class SecretKey {
  free(): void;
/**
* generate random key
* @returns {SecretKey}
*/
  static random_dlog(): SecretKey;
/**
* Parse dlog secret key from bytes (SEC-1-encoded scalar)
* @param {Uint8Array} bytes
* @returns {SecretKey}
*/
  static dlog_from_bytes(bytes: Uint8Array): SecretKey;
/**
* Parse Diffie-Hellman tuple secret key from bytes.
* secret is expected as SEC-1-encoded scalar of 32 bytes,
* g,h,u,v are expected as 33-byte compressed points
* @param {Uint8Array} secret
* @param {Uint8Array} g
* @param {Uint8Array} h
* @param {Uint8Array} u
* @param {Uint8Array} v
* @returns {SecretKey}
*/
  static dht_from_bytes(secret: Uint8Array, g: Uint8Array, h: Uint8Array, u: Uint8Array, v: Uint8Array): SecretKey;
/**
* Address (encoded public image)
* @returns {Address}
*/
  get_address(): Address;
/**
* Parse secret key from bytes (expected 32 bytes for Dlog, 32(secret)+33(g)+33(h)+33(u)+33(v)=164 bytes for DHT)
* secret is expected as SEC-1-encoded scalar of 32 bytes,
* g,h,u,v are expected as 33-byte compressed points
* @param {Uint8Array} bytes
* @returns {SecretKey}
*/
  static from_bytes(bytes: Uint8Array): SecretKey;
/**
* Serialized secret key (32 bytes for Dlog, 32(secret)+33(g)+33(h)+33(u)+33(v)=164 bytes for DHT)
* DHT format is the same as in from_bytes
* @returns {Uint8Array}
*/
  to_bytes(): Uint8Array;
/**
* Parse secret key from JSON string (Dlog expected as base16-encoded bytes, DHT in node REST API format)
* @param {string} json_str
* @returns {SecretKey}
*/
  static from_json(json_str: string): SecretKey;
/**
* Encode secret key to JSON string (Dlog as base16-encoded bytes, DHT in node REST API format)
* @returns {string}
*/
  to_json(): string;
}
/**
* SecretKey collection
*/
export class SecretKeys {
  free(): void;
/**
* Create empty SecretKeys
*/
  constructor();
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {SecretKey}
*/
  get(index: number): SecretKey;
/**
* Adds an elements to the collection
* @param {SecretKey} elem
*/
  add(elem: SecretKey): void;
}
/**
* Naive box selector, collects inputs until target balance is reached
*/
export class SimpleBoxSelector {
  free(): void;
/**
* Create empty SimpleBoxSelector
*/
  constructor();
/**
* Selects inputs to satisfy target balance and tokens.
* `inputs` - available inputs (returns an error, if empty),
* `target_balance` - coins (in nanoERGs) needed,
* `target_tokens` - amount of tokens needed.
* Returns selected inputs and box assets(value+tokens) with change.
* @param {ErgoBoxes} inputs
* @param {BoxValue} target_balance
* @param {Tokens} target_tokens
* @returns {BoxSelection}
*/
  select(inputs: ErgoBoxes, target_balance: BoxValue, target_tokens: Tokens): BoxSelection;
}
/**
* Token represented with token id paired with it's amount
*/
export class Token {
  free(): void;
/**
* Create a token with given token id and amount
* @param {TokenId} token_id
* @param {TokenAmount} amount
*/
  constructor(token_id: TokenId, amount: TokenAmount);
/**
* Get token id
* @returns {TokenId}
*/
  id(): TokenId;
/**
* Get token amount
* @returns {TokenAmount}
*/
  amount(): TokenAmount;
/**
* JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
* @returns {string}
*/
  to_json(): string;
/**
* JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
* (similar to [`Self::to_json`], but as JS object with token amount encoding as string)
* @returns {any}
*/
  to_js_eip12(): any;
}
/**
* Token amount with bound checks
*/
export class TokenAmount {
  free(): void;
/**
* Create from i64 with bounds check
* @param {I64} v
* @returns {TokenAmount}
*/
  static from_i64(v: I64): TokenAmount;
/**
* Get value as signed 64-bit long (I64)
* @returns {I64}
*/
  as_i64(): I64;
/**
* big-endian byte array representation
* @returns {Uint8Array}
*/
  to_bytes(): Uint8Array;
}
/**
* Token id (32 byte digest)
*/
export class TokenId {
  free(): void;
/**
* Create token id from ergo box id (32 byte digest)
* @param {BoxId} box_id
* @returns {TokenId}
*/
  static from_box_id(box_id: BoxId): TokenId;
/**
* Parse token id (32 byte digest) from base16-encoded string
* @param {string} str
* @returns {TokenId}
*/
  static from_str(str: string): TokenId;
/**
* Base16 encoded string
* @returns {string}
*/
  to_str(): string;
/**
* Returns byte array (32 bytes)
* @returns {Uint8Array}
*/
  as_bytes(): Uint8Array;
}
/**
* Array of tokens
*/
export class Tokens {
  free(): void;
/**
* Create empty Tokens
*/
  constructor();
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {Token}
*/
  get(index: number): Token;
/**
* Adds an elements to the collection
* @param {Token} elem
*/
  add(elem: Token): void;
}
/**
*
* * ErgoTransaction is an atomic state transition operation. It destroys Boxes from the state
* * and creates new ones. If transaction is spending boxes protected by some non-trivial scripts,
* * its inputs should also contain proof of spending correctness - context extension (user-defined
* * key-value map) and data inputs (links to existing boxes in the state) that may be used during
* * script reduction to crypto, signatures that satisfies the remaining cryptographic protection
* * of the script.
* * Transactions are not encrypted, so it is possible to browse and view every transaction ever
* * collected into a block.
* 
*/
export class Transaction {
  free(): void;
/**
* Create new transaction
* @param {Inputs} inputs
* @param {DataInputs} data_inputs
* @param {ErgoBoxCandidates} outputs
*/
  constructor(inputs: Inputs, data_inputs: DataInputs, outputs: ErgoBoxCandidates);
/**
* Create Transaction from UnsignedTransaction and an array of proofs in the same order as
* UnsignedTransaction.inputs with empty proof indicated with empty byte array
* @param {UnsignedTransaction} unsigned_tx
* @param {(Uint8Array)[]} proofs
* @returns {Transaction}
*/
  static from_unsigned_tx(unsigned_tx: UnsignedTransaction, proofs: (Uint8Array)[]): Transaction;
/**
* Get id for transaction
* @returns {TxId}
*/
  id(): TxId;
/**
* JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
* @returns {string}
*/
  to_json(): string;
/**
* JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
* (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)
* @returns {any}
*/
  to_js_eip12(): any;
/**
* parse from JSON
* supports Ergo Node/Explorer API and box values and token amount encoded as strings
* @param {string} json
* @returns {Transaction}
*/
  static from_json(json: string): Transaction;
/**
* Inputs for transaction
* @returns {Inputs}
*/
  inputs(): Inputs;
/**
* Data inputs for transaction
* @returns {DataInputs}
*/
  data_inputs(): DataInputs;
/**
* Output candidates for transaction
* @returns {ErgoBoxCandidates}
*/
  output_candidates(): ErgoBoxCandidates;
/**
* Returns ErgoBox's created from ErgoBoxCandidate's with tx id and indices
* @returns {ErgoBoxes}
*/
  outputs(): ErgoBoxes;
/**
* Returns serialized bytes or fails with error if cannot be serialized
* @returns {Uint8Array}
*/
  sigma_serialize_bytes(): Uint8Array;
/**
* Parses Transaction or fails with error
* @param {Uint8Array} data
* @returns {Transaction}
*/
  static sigma_parse_bytes(data: Uint8Array): Transaction;
/**
* Check the signature of the transaction's input corresponding
* to the given input box, guarded by P2PK script
* @param {ErgoBox} input_box
* @returns {boolean}
*/
  verify_p2pk_input(input_box: ErgoBox): boolean;
}
/**
* TransactionHintsBag
*/
export class TransactionHintsBag {
  free(): void;
/**
* Empty TransactionHintsBag
* @returns {TransactionHintsBag}
*/
  static empty(): TransactionHintsBag;
/**
* Adding hints for input
* @param {number} index
* @param {HintsBag} hints_bag
*/
  add_hints_for_input(index: number, hints_bag: HintsBag): void;
/**
* Outputting HintsBag corresponding for an input index
* @param {number} index
* @returns {HintsBag}
*/
  all_hints_for_input(index: number): HintsBag;
/**
* Return JSON object (node format)
* @returns {any}
*/
  to_json(): any;
/**
* Parse from JSON object (node format)
* @param {string} json
* @returns {TransactionHintsBag}
*/
  static from_json(json: string): TransactionHintsBag;
}
/**
* Unsigned transaction builder
*/
export class TxBuilder {
  free(): void;
/**
* Suggested transaction fee (semi-default value used across wallets and dApps as of Oct 2020)
* @returns {BoxValue}
*/
  static SUGGESTED_TX_FEE(): BoxValue;
/**
* Creates new TxBuilder
* `box_selection` - selected input boxes (via [`super::box_selector`])
* `output_candidates` - output boxes to be "created" in this transaction,
* `current_height` - chain height that will be used in additionally created boxes (change, miner's fee, etc.),
* `fee_amount` - miner's fee,
* `change_address` - change (inputs - outputs) will be sent to this address,
* will be given to miners,
* @param {BoxSelection} box_selection
* @param {ErgoBoxCandidates} output_candidates
* @param {number} current_height
* @param {BoxValue} fee_amount
* @param {Address} change_address
* @returns {TxBuilder}
*/
  static new(box_selection: BoxSelection, output_candidates: ErgoBoxCandidates, current_height: number, fee_amount: BoxValue, change_address: Address): TxBuilder;
/**
* Set transaction's data inputs
* @param {DataInputs} data_inputs
*/
  set_data_inputs(data_inputs: DataInputs): void;
/**
* Set context extension for a given input
* @param {BoxId} box_id
* @param {ContextExtension} context_extension
*/
  set_context_extension(box_id: BoxId, context_extension: ContextExtension): void;
/**
* Permits the burn of the given token amount, i.e. allows this token amount to be omitted in the outputs
* @param {Tokens} tokens
*/
  set_token_burn_permit(tokens: Tokens): void;
/**
* Build the unsigned transaction
* @returns {UnsignedTransaction}
*/
  build(): UnsignedTransaction;
/**
* Get box selection
* @returns {BoxSelection}
*/
  box_selection(): BoxSelection;
/**
* Get data inputs
* @returns {DataInputs}
*/
  data_inputs(): DataInputs;
/**
* Get outputs EXCLUDING fee and change
* @returns {ErgoBoxCandidates}
*/
  output_candidates(): ErgoBoxCandidates;
/**
* Get current height
* @returns {number}
*/
  current_height(): number;
/**
* Get fee amount
* @returns {BoxValue}
*/
  fee_amount(): BoxValue;
/**
* Get change address
* @returns {Address}
*/
  change_address(): Address;
}
/**
* Transaction id
*/
export class TxId {
  free(): void;
/**
* Zero (empty) transaction id (to use as dummy value in tests)
* @returns {TxId}
*/
  static zero(): TxId;
/**
* get the tx id as bytes
* @returns {string}
*/
  to_str(): string;
/**
* convert a hex string into a TxId
* @param {string} s
* @returns {TxId}
*/
  static from_str(s: string): TxId;
}
/**
* Unsigned inputs used in constructing unsigned transactions
*/
export class UnsignedInput {
  free(): void;
/**
* Create new unsigned input instance from box id and extension
* @param {BoxId} box_id
* @param {ContextExtension} ext
*/
  constructor(box_id: BoxId, ext: ContextExtension);
/**
* Create a new unsigned input from the provided box id
* using an empty context extension
* @param {BoxId} box_id
* @returns {UnsignedInput}
*/
  static from_box_id(box_id: BoxId): UnsignedInput;
/**
* Get box id
* @returns {BoxId}
*/
  box_id(): BoxId;
/**
* Get extension
* @returns {ContextExtension}
*/
  extension(): ContextExtension;
}
/**
* Collection of unsigned signed inputs
*/
export class UnsignedInputs {
  free(): void;
/**
* Create empty UnsignedInputs
*/
  constructor();
/**
* Returns the number of elements in the collection
* @returns {number}
*/
  len(): number;
/**
* Returns the element of the collection with a given index
* @param {number} index
* @returns {UnsignedInput}
*/
  get(index: number): UnsignedInput;
/**
* Add an element to the collection
* @param {UnsignedInput} b
*/
  add(b: UnsignedInput): void;
}
/**
* Unsigned (inputs without proofs) transaction
*/
export class UnsignedTransaction {
  free(): void;
/**
* Create a new unsigned transaction
* @param {UnsignedInputs} inputs
* @param {DataInputs} data_inputs
* @param {ErgoBoxCandidates} output_candidates
*/
  constructor(inputs: UnsignedInputs, data_inputs: DataInputs, output_candidates: ErgoBoxCandidates);
/**
* Consumes the calling UnsignedTransaction and returns a new UnsignedTransaction containing
* the ContextExtension in the provided input box id or returns an error if the input box cannot be found.
* After the call the calling UnsignedTransaction will be null.
* @param {BoxId} input_id
* @param {ContextExtension} ext
* @returns {UnsignedTransaction}
*/
  with_input_context_ext(input_id: BoxId, ext: ContextExtension): UnsignedTransaction;
/**
* Get id for transaction
* @returns {TxId}
*/
  id(): TxId;
/**
* Inputs for transaction
* @returns {UnsignedInputs}
*/
  inputs(): UnsignedInputs;
/**
* Data inputs for transaction
* @returns {DataInputs}
*/
  data_inputs(): DataInputs;
/**
* Output candidates for transaction
* @returns {ErgoBoxCandidates}
*/
  output_candidates(): ErgoBoxCandidates;
/**
* JSON representation as text (compatible with Ergo Node/Explorer API, numbers are encoded as numbers)
* @returns {string}
*/
  to_json(): string;
/**
* JSON representation according to EIP-12 <https://github.com/ergoplatform/eips/pull/23>
* (similar to [`Self::to_json`], but as JS object with box value and token amount encoding as strings)
* @returns {any}
*/
  to_js_eip12(): any;
/**
* parse from JSON
* supports Ergo Node/Explorer API and box values and token amount encoded as strings
* @param {string} json
* @returns {UnsignedTransaction}
*/
  static from_json(json: string): UnsignedTransaction;
/**
* Returns distinct token id from output_candidates as array of byte arrays
* @returns {(Uint8Array)[]}
*/
  distinct_token_ids(): (Uint8Array)[];
}
/**
* A collection of secret keys. This simplified signing by matching the secret keys to the correct inputs automatically.
*/
export class Wallet {
  free(): void;
/**
* Create wallet instance loading secret key from mnemonic
* Returns None if a DlogSecretKey cannot be parsed from the provided phrase
* @param {string} mnemonic_phrase
* @param {string} mnemonic_pass
* @returns {Wallet}
*/
  static from_mnemonic(mnemonic_phrase: string, mnemonic_pass: string): Wallet;
/**
* Create wallet using provided secret key
* @param {SecretKeys} secret
* @returns {Wallet}
*/
  static from_secrets(secret: SecretKeys): Wallet;
/**
* Add a secret to the wallets prover
* @param {SecretKey} secret
*/
  add_secret(secret: SecretKey): void;
/**
* Sign a transaction:
* `tx` - transaction to sign
* `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]
* `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]
* @param {ErgoStateContext} _state_context
* @param {UnsignedTransaction} tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @returns {Transaction}
*/
  sign_transaction(_state_context: ErgoStateContext, tx: UnsignedTransaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes): Transaction;
/**
* Sign a multi signature transaction:
* `tx` - transaction to sign
* `boxes_to_spend` - boxes corresponding to [`UnsignedTransaction::inputs`]
* `data_boxes` - boxes corresponding to [`UnsignedTransaction::data_inputs`]
* `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]
* @param {ErgoStateContext} _state_context
* @param {UnsignedTransaction} tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @param {TransactionHintsBag} tx_hints
* @returns {Transaction}
*/
  sign_transaction_multi(_state_context: ErgoStateContext, tx: UnsignedTransaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes, tx_hints: TransactionHintsBag): Transaction;
/**
* Sign a transaction:
* `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input
* added a script reduction result.
* @param {ReducedTransaction} reduced_tx
* @returns {Transaction}
*/
  sign_reduced_transaction(reduced_tx: ReducedTransaction): Transaction;
/**
* Sign a multi signature reduced transaction:
* `reduced_tx` - reduced transaction, i.e. unsigned transaction where for each unsigned input
* added a script reduction result.
* `tx_hints` - transaction hints bag corresponding to [`TransactionHintsBag`]
* @param {ReducedTransaction} reduced_tx
* @param {TransactionHintsBag} tx_hints
* @returns {Transaction}
*/
  sign_reduced_transaction_multi(reduced_tx: ReducedTransaction, tx_hints: TransactionHintsBag): Transaction;
/**
* Generate Commitments for unsigned tx
* @param {ErgoStateContext} _state_context
* @param {UnsignedTransaction} tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @returns {TransactionHintsBag}
*/
  generate_commitments(_state_context: ErgoStateContext, tx: UnsignedTransaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes): TransactionHintsBag;
/**
* Generate Commitments for reduced Transaction
* @param {ReducedTransaction} reduced_tx
* @returns {TransactionHintsBag}
*/
  generate_commitments_for_reduced_transaction(reduced_tx: ReducedTransaction): TransactionHintsBag;
/**
* Sign an arbitrary message using a P2PK address
* @param {Address} address
* @param {Uint8Array} message
* @returns {Uint8Array}
*/
  sign_message_using_p2pk(address: Address, message: Uint8Array): Uint8Array;
/**
* Sign a given tx input
* @param {number} input_idx
* @param {ErgoStateContext} state_context
* @param {UnsignedTransaction} tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @returns {Input}
*/
  sign_tx_input(input_idx: number, state_context: ErgoStateContext, tx: UnsignedTransaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes): Input;
/**
* Sign a given multi-signature tx input
* @param {number} input_idx
* @param {ErgoStateContext} state_context
* @param {UnsignedTransaction} tx
* @param {ErgoBoxes} boxes_to_spend
* @param {ErgoBoxes} data_boxes
* @param {TransactionHintsBag} tx_hints
* @returns {Input}
*/
  sign_tx_input_multi(input_idx: number, state_context: ErgoStateContext, tx: UnsignedTransaction, boxes_to_spend: ErgoBoxes, data_boxes: ErgoBoxes, tx_hints: TransactionHintsBag): Input;
}
